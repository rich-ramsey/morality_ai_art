---
title: "effects"
author: "Rich"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This file visualises and tabulates parameters from the most complex model for the morality aesthetics project.

# load the libraries that we will be using #

## install ##

only the additional packages (not already installed are required).
in this case, that is whatever we use to make tables.

```{r install-pkg}
# install.packages(c("flextable"))
```

take a snapshot of loaded packages and update the lock.file using renv

```{r snapshot-renv}
# take a snapshot and update the lock.file
# renv::snapshot() # this is only necessary when new packages or installed or packages are updated.
```

## load ##

```{r load-pkg}
pkg <- c("tidyverse", "RColorBrewer", "patchwork", "brms", 
         "tidybayes", "bayesplot", "future", "parallel", "flextable")

lapply(pkg, library, character.only = TRUE)
```

## adjust multicore settings ##

```{r set-options}
options(mc.cores = parallel::detectCores(),
        future.fork.enable = TRUE,
        future.rng.onMisuse = "ignore") ## automatically set in RStudio

supportsMulticore()

detectCores()
```

## plot settings ##

```{r}
## Set the amount of dodge in figures
pd <- position_dodge(0.7)
pd2 <- position_dodge(1)
```

theme settings for ggplot

```{r, eval = F}
theme_set(
  theme_bw() +
    theme(text = element_text(size = 18), 
          title = element_text(size = 18),
          legend.position = "bottom")
)
```

## table settings ##

```{r}
set_flextable_defaults(
  theme_fun = theme_vanilla,
  background.color = "white"
)
```


## read in previously saved brms models object files and/or fits ##

If available, this saves time computing them each time 

```{r}
# pp models
bf <- readRDS("exp1/models/bf.rds")
```

now read in the fits, if available.

```{r}
# d_fitpp.1 <- read_csv("fits/d_fitpp.1.csv")
# d_fitpp.2 <- read_csv("fits/d_fitpp.2.csv")
# d_fitpp.3 <- read_csv("fits/d_fitpp.3.csv")
# d_fitpp.4 <- read_csv("fits/d_fitpp.4.csv")

d_fit <- read_csv("exp1/fits/d_fit.csv")
head(d_fit)

d_fit_summary <- read_csv("exp1/fits/d_fit_summary.csv") %>%
  mutate(training = factor(training, levels=c("pre","post")),
         image_type = factor(image_type, levels=c("realism","sorolla")),
         response = factor(response, levels = c("understanding", "creativity", "thinking", "challenge")),
         training_type = factor(training_type, levels = c("InDepth", "Brief", "None")),
         .category = factor(.category, levels = unique(.category))) %>%
  group_by(training, image_type, training_type, .draw, response)
head(d_fit_summary)
```

## read in the data ##

```{r}
datad <- read_csv("exp1/data/datad.csv") 
  # mutate(pid = factor(pid, levels = unique(pid)),
   #       item = factor(item, levels = unique(item)),
   #       training = factor(training, levels=c("pre","post")),
   #         training_type = factor(training_type, levels = c("InDepth", "Brief","None" )),
   #       image_type = factor(image_type, levels=c("realism","sorolla")))
head(datad)
```

# section 1 #

## Look at the point and interval estimates for model bpp5.3 (the full model) ##

using posterior_samples and tidybayes

```{r}
post <- as_draws_df(bf) %>%  #
  select(-lp__) %>% 
  as_tibble()

post_summary <- posterior_summary(bf, robust = TRUE)

# all fixed effects
post_qi_b <- post %>%
  select(starts_with("b_")) %>% 
  pivot_longer(everything()) %>% 
  group_by(name) %>% 
  median_qi(value)
head(post_qi_b)

# fixed effects (minus per item thresholds)
post_qi_fix <- post %>%
  select(starts_with("b_") & contains(c("group", "image_cat"))) %>% 
  pivot_longer(everything()) %>% 
  group_by(name) %>% 
  median_qi(value)
head(post_qi_fix)

# varying effects - SD
post_qi_sd <- post %>%
  select(starts_with("sd_")) %>% 
  pivot_longer(everything()) %>% 
  group_by(name) %>% 
  median_qi(value)
head(post_qi_sd)

# individual item and SD variation
# all individual items/pt variation
vary_vals <- post %>%
  select(starts_with("r_")) %>% 
  pivot_longer(everything()) %>% 
  group_by(name) %>% 
  median_qi(value)
head(vary_vals)

# item variation
vary_vals_item <- post %>%
  select(starts_with("r_")) %>% 
  pivot_longer(everything()) %>% 
  group_by(name) %>% 
  filter(str_detect(name, "item")) %>% 
  median_qi(value)
head(vary_vals_item)

# participant variation
vary_vals_pt <- post %>%
  select(starts_with("r_")) %>% 
  pivot_longer(everything()) %>% 
  group_by(name) %>% 
  filter(str_detect(name, "pid")) %>% 
  median_qi(value)
head(vary_vals_pt)
```

# section 2 #

## Visualise fixed effects ##

Using posterior_samples and tidybayes

```{r}
## fixed effects of interest, excluding basic intercepts for the ordinal model 
tidy_fixed <- post %>% 
  select(starts_with("b_") & contains(c("group", "image_cat"))) %>% # select and rename in simpler labels
  pivot_longer(everything()) %>% # move from wide to long
  mutate(key = factor(name, levels=unique(name)),
         dv = if_else(str_detect(key, "use"), "use",
              if_else(str_detect(key, "gain"), "gain",
              if_else(str_detect(key, "prestige"), "prestige", 
              if_else(str_detect(key, "status"), "status", "appreciation")))),
         term = if_else(str_detect(key, "group:image_cat"), "group*image_type",
                if_else(str_detect(key, "group"), "group", "image_type")),
         dv = factor(dv, levels=unique(dv)),
         term = factor(term, levels=unique(term)))  
head(tidy_fixed)
tail(tidy_fixed)
str(tidy_fixed)

## data check
check.labels <- tidy_fixed %>% 
 group_by(key, dv, term) %>% 
 distinct(key, dv, term)
check.labels

## plot
p_tidy_fixed <- ggplot(tidy_fixed, aes(x = value, y = fct_rev(term), fill=term)) +  
  geom_vline(xintercept = 0, color = "grey", alpha = 5/10) +
  stat_halfeye(point_size = 1) +
  labs(title = "Multivariate model coefficient plot for fixed effects (predictors)",
       x = NULL, y = NULL) +
  scale_fill_brewer(palette="Dark2") +
  theme(panel.grid   = element_blank(),
        panel.grid.major.y = element_line(color = alpha("firebrick4", 1/2), linetype = 3),
        axis.text.y  = element_text(hjust = 0),
        axis.ticks.y = element_blank(),
        legend.position = "none")+
  # coord_cartesian(xlim =c(-1, 1))+
  # scale_x_continuous(breaks=seq(-1, 1, 1))+
  facet_wrap(~dv, ncol = 5)
p_tidy_fixed

ggsave ("exp1/figures/bf_fixef.jpeg",
        width = 8, height = 6)
```

## make a table of fixed effects ##

```{r}
## make a df
fix_tab <- post_qi_fix %>%
  mutate(key = factor(name, levels=unique(name)),
         dv = if_else(str_detect(key, "use"), "use",
              if_else(str_detect(key, "gain"), "gain",
              if_else(str_detect(key, "prestige"), "prestige", 
              if_else(str_detect(key, "status"), "status", "appreciation")))),
         term = if_else(str_detect(key, "group:image_cat"), "group*image_type",
                if_else(str_detect(key, "group"), "group", "image_type")),
         dv = factor(dv, 
                     levels=c("use", "gain", "prestige", "status", "appreciation")),
         term = factor(term, 
                       levels=c("group", "image_type", "group*image_type")))   %>% 
  arrange(dv, term) %>%
  select(dv, term, value, .lower, .upper) %>% 
  mutate(across(where(is.double), round, 2))
fix_tab

## make a table using flextable (still needs a title but that can be fixed later, depending on the doc it is being used in)
p_fix_tab <- flextable(fix_tab) 
p_fix_tab

## save it
save_as_image(p_fix_tab, path = "exp1/tables/fixef.png")

## this table still needs polishing, but you get the basic idea
```

# section 3 #

# Visualise varying effects #

using posterior samples and tidybayes.

# Variance at the group level (i.e., intercept for item and intercepts and effects across participants)

```{r}
## varying effects of interest, including item, as well as participant and effects across pts
tidy_vary <- post %>% 
  select(contains("sd_")) %>% 
  pivot_longer(everything()) %>% 
  mutate(key = factor(name, levels=unique(name)),
         group = if_else(str_detect(key, "item"), "item", "pid"),
         term = if_else(str_detect(key, "Intercept") 
                        & group == "item","item_intercept",
                if_else(str_detect(key, "Intercept") 
                        & group == "pid","pid_intercept", "image_type")),
         dv = if_else(str_detect(key, "use"), "use",
              if_else(str_detect(key, "gain"), "gain",
              if_else(str_detect(key, "prestige"), "prestige", 
              if_else(str_detect(key, "status"), "status", "appreciation")))),
         group = factor(group, levels=unique(group)),
         term = factor(term, levels=unique(term)),
         dv = factor(dv,levels=unique(dv))) %>% 
  arrange(group)
head(tidy_vary)
tail(tidy_vary)

check.vary <- tidy_vary %>% 
  group_by(key, group, term, dv) %>% 
  distinct(key, group, term, dv)
check.vary

p_tidy_vary <- ggplot(tidy_vary, aes(x = value, y = fct_rev(term), fill=term)) +  
  geom_vline(xintercept = 0, color = "grey", alpha = 5/10) +
  stat_halfeye() +
  labs(title = "SD plot for varying effects",
       x = NULL, y = NULL) +
  scale_fill_brewer(palette="Dark2") +
  theme(panel.grid   = element_blank(),
        panel.grid.major.y = element_line(color = alpha("firebrick4", 1/2), linetype = 3),
        # axis.text.y  = element_blank(),
        # axis.ticks.y = element_blank(),
        legend.position = "none") +
  # coord_cartesian(xlim =c(0, 1.5)) +
  # scale_x_continuous(breaks=seq(0,1.5,0.5)) +
  facet_wrap(~dv,ncol=5)
p_tidy_vary

ggsave ("exp1/figures/varypp.jpeg",
        width = 8, height = 6)
```

# Variance within group levels i.e., at the individual item and participant level #

Note - this should be in a centred metric, so that deviation from the group average (zero) can be visualised.

# filter and wrangle random effects within items and participants #

# item level #

```{r}
# item level
# using post_summary (from posterior_summary)
# 20 items x 2 image_types x 5 dvs = 200
vary_item <- post_summary %>% 
  data.frame() %>% 
  rownames_to_column("param") %>% 
  filter(str_detect(param, "r_item"),
         str_detect(param, "cor", negate = TRUE)) %>% 
  mutate(dv = if_else(str_detect(param, "use"), "use",
              if_else(str_detect(param, "gain"), "gain",
              if_else(str_detect(param, "prestige"), "prestige", 
              if_else(str_detect(param, "status"), "status", "appreciation")))),
         term = "item_intercept",
         dv = factor(dv, levels = unique(dv))) %>% 
  arrange(dv, Estimate) %>% 
  mutate(rank = rep(1:40, times=5),
         outlier = if_else(Q2.5 > 0 | Q97.5 < 0, "yes", "no"), 
         outlier = factor(outlier, levels = c("no", "yes")))
head(vary_item)
```

# participant level #

```{r}
# 100 pts x 2 terms x 5 dvs = 1000
vary_pt <- post_summary %>%
  data.frame() %>% 
  rownames_to_column("param") %>% 
  filter(str_detect(param, "r_pid"),
         str_detect(param, "cor", negate = TRUE)) %>% 
  mutate(dv = if_else(str_detect(param, "use"), "use",
              if_else(str_detect(param, "gain"), "gain",
              if_else(str_detect(param, "prestige"), "prestige", 
              if_else(str_detect(param, "status"), "status", "appreciation")))),
         term = if_else(str_detect(param, "Intercept"), "pid_intercept", "pid_image_type"),
         dv = factor(dv, levels = unique(dv)),
         term = factor(term, levels = unique(term))) %>% 
  arrange(dv, term, Estimate) %>% 
  mutate(rank = rep(1:100, times=10),
         outlier = if_else(Q2.5 > 0 | Q97.5 < 0, "yes", "no"), 
        outlier = factor(outlier, levels = c("no", "yes")))
head(vary_pt)

check.vary.pt <- vary_pt %>% 
  distinct(dv, term)
check.vary.pt
```

# join item and pt varyvals together #

```{r}
tidy_varyvals <- vary_item %>% 
  union(vary_pt) %>% 
  mutate(term = factor(term, levels = unique(term)))
head(tidy_varyvals)
```

# plot varying effects via caterpillar plots #

```{r}
p_tidy_varyvals <- ggplot(tidy_varyvals, aes(x=rank, y=Estimate, colour=outlier))+
  geom_pointrange(aes(ymin=Q2.5,ymax=Q97.5),fatten = 0.5)+
  geom_hline(yintercept=0, colour = "red")+
  theme_bw()+
  scale_colour_manual(values=c("darkgrey","black")) +
  labs(title = "Varying effects by stimulus item and participant",
       x = "stimulus item / participant")+
  theme(axis.text.x  = element_blank())+
  guides(colour = "none")+
  facet_grid(dv~term, scales = "free_x")
p_tidy_varyvals

ggsave ("exp1/figures/varyvalspp.jpeg",
        width = 8, height = 6)
```

# section 4 #

## Plot in the original probability metric as a function of conditions ##

## fit 1

```{r}
plan(multicore)
d_fit.1 <- datad %>%
  distinct(pid, item, group, image_cat) %>%
  add_epred_draws(bf,
                   ndraws=100,
                   resp = "use") %>% 
  mutate(response = "response1")
head(d_fit.1)

# write_csv(d_fit.1, "exp1/fits/d_fit.1.csv")
```

##  fit 2

```{r}
plan(multicore)
d_fit.2 <- datad %>%
  distinct(pid, item, group, image_cat) %>%
  add_epred_draws(bf,
                   ndraws=100,
                   resp = "gain") %>% 
  mutate(response = "response2")
head(d_fit.2)

# write_csv(d_fit.2, "fits/d_fit.2.csv")
```

##  fit 3

```{r}
plan(multicore)
d_fit.3 <- datad %>%
  distinct(pid, item, group, image_cat) %>%
  add_epred_draws(bf,
                   ndraws=100,
                   resp = "prestige") %>% 
  mutate(response = "response3")
head(d_fit.3)

# write_csv(d_fit.3, "fits/d_fit.3.csv")
```

##  fit 4

```{r}
plan(multicore)
d_fit.4 <- datad %>%
  distinct(pid, item, group, image_cat) %>%
  add_epred_draws(bf,
                   ndraws=100,
                   resp = "status") %>% 
  mutate(response = "response4")
head(d_fit.4)

# write_csv(d_fit.4, "fits/d_fit.4.csv")
```

##  fit 5

```{r}
plan(multicore)
d_fit.5 <- datad %>%
  distinct(pid, item, group, image_cat) %>%
  add_epred_draws(bf,
                   ndraws=100,
                   resp = "appreciation") %>% 
  mutate(response = "response5")
head(d_fit.5)

# write_csv(d_fit.5, "fits/d_fit.5.csv")
```

## combine the fits ##

```{r}
d_fit <- bind_rows(d_fit.1, d_fit.2, d_fit.3, d_fit.4, d_fit.5)
head(d_fit)
str(d_fit)

write_csv(d_fit, "exp1/fits/d_fit.csv")

check.labels <- d_fit %>%
  distinct(group, image_cat, .row, .category) 
head(check.labels)
tail(check.labels)
```

## create a summary fit ##

mutate and rename the column that shows the DV, then create and rename factors, and summarise across items.

```{r}
d_fit_summary <- d_fit %>% 
  mutate(response = if_else(response == "response1", "use",
                    if_else(response == "response2", "gain",
                    if_else(response == "response3", "prestige",
                    if_else(response == "response4", "status", "appreciation")))),
         image_type = if_else(image_cat == -0.5, "landscape", "people"),
         group = if_else(group == -0.5, "no_info", "info")) %>% 
  mutate(response = factor(response, 
                           levels = c("use", "gain", "prestige", "status", "appreciation")),
         pid = factor(pid, levels = unique(pid)),
         item = factor(item, levels = unique(item)),
         image_type = factor(image_type, 
                             levels = c("landscape", "people")),
         .category = factor(.category, levels = unique(.category))) %>% 
  group_by(group, image_type, .draw, response, .category) %>% 
  summarise(mean=mean(.epred)) # .groups
head(d_fit_summary)
tail(d_fit_summary)

check.labels <- d_fit_summary %>%
  group_by(group, image_type, .category, response) %>%
  distinct(group, image_type, .category, response)
head(check.labels)
tail(check.labels)

# note - .category is the 1-5 response scale

# save out a summary fit file
write_csv(d_fit_summary, "exp1/fits/d_fit_summary.csv")
```

and plot

```{r}
# note - error bars cannot be seen currently. point is too large. either modify point/interval sizes or plot separately.
p_fit <- ggplot(d_fit_summary, 
                aes(x = group, y = mean, color = .category)) +
  stat_pointinterval(position = position_dodge(width = 0.9), fatten_point = 0.5) +
  scale_size_continuous(guide = "none") +
  labs(title = "P(category | condition)", 
       x = "condition") +
  theme(legend.direction = "horizontal", legend.position = "top", 
        legend.title = element_blank(), legend.text = element_text(size=10, face="bold")) +
  guides(colour = guide_legend(nrow=1, override.aes = list(alpha=1,size=7)))+
  facet_grid(response~image_type)
p_fit
# save it
# ggsave ("figures/p_fit_aesthetics.jpeg")

p_fit_n <- ggplot(d_fit_summary, 
                  aes(x = .category, y = mean, color = group)) +
  stat_pointinterval(position = position_dodge(width = .7), fatten_point = 0.5) +
  scale_size_continuous(guide = "none") +
  theme_bw() +
  ggtitle("P(category | condition)") +
  theme(legend.position = "bottom", legend.title = element_blank(), 
        legend.text = element_text(size=10, face="bold")) +
  facet_grid(response~image_type)
p_fit_n
# ggsave ("figures/p_fit_n_aesthetics.jpeg")
```

# plot in the rating scale metric as a function of conditions #

```{r}
d_fit_alt <- d_fit_summary %>% 
  mutate(sum=cumsum(mean),cat_by_prob=as.numeric(.category) * mean) %>% 
  mutate(sum2=sum(cat_by_prob))
head(d_fit_alt)
```

# and plot #

```{r}
# using facet_wrap
p_fit_alt <- ggplot(d_fit_alt, aes(x = group, y = sum2, group =.draw, colour=.draw)) +
  geom_line(alpha = 4/10) +
  scale_y_continuous("response", limits=c(1, 5), breaks=seq(1, 5, 1)) +
  labs(title = "ratings by condition", 
       x = "condition") +
  theme(legend.position = "none")+
  facet_grid(response~image_type)
p_fit_alt
# save it
# ggsave ("figures/plot_p3.jpeg")
```

# overlaying lines (to emphasise overlap or not) #

```{r}
p_fit_alt.2 <- ggplot(d_fit_alt, aes(x = group, y = sum2, group =interaction(image_type,.draw), 
                                       colour=image_type)) +
  geom_line(alpha = 4/10) +
  scale_y_continuous("response", limits=c(1, 5), breaks=seq(1, 5, 1)) +
  labs(title = "Ratings by group and image type", 
       x = "group") +
  scale_colour_brewer(palette = "Dark2") +
  theme(legend.position = "bottom")+
  guides(colour = guide_legend(override.aes = list(alpha=1,size=2)))+
  facet_wrap(~response, ncol = 5)
p_fit_alt.2

ggsave ("exp1/figures/p_fit.jpeg",
        width = 8, height = 6)
```

to do:

maybe the above plot with error bars for quantile intervals?

at present, we find evidence for a numerical difference, in line with our prediction re: info., but
it is not overly convincing or large. But that's ok, to me.

print session info

```{r}
sessionInfo()
```
